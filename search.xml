<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Integer to Roman]]></title>
    <url>%2F2018%2F03%2F13%2FInteger-to-Roman%2F</url>
    <content type="text"><![CDATA[这道题主要看的是对罗马数字与阿拉伯数字的转换规则是否清楚，若是不清楚会很难做，了解后则会很简单；12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int num; printf("请输入要转换的数字:"); scanf("%d",&amp;num); char *thousands[4]=&#123;"","M","MM","MMM"&#125;; char *hundreds[10]=&#123;"","C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; char *tens[10] = &#123;"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"&#125;; char *digits[10] = &#123;"","I","II","III","IV","V","VI","VII","VIII","IX"&#125;; printf("%s",thousands[num/1000]); printf("%s",hundreds[num%1000/100]); printf("%s",tens[num%100/10]); printf("%s",digits[num%10]); return 0;&#125; 不了解罗马数字规则的同学可以参考http://baike.baidu.com/link?url=injU8M4bAoc2zRZQ1GtgrfvuzCJO9PLnq6fpQGJLenakbzo-rS8p-qsYHR_81-aN另外，这里需要注意char与char[]的区别，这里定义的是一个一维字符数组，并进行初始化，一维数组的元素只能是单个的字符，而上面的数据却是字符串，所以，在编译时会报错误。所以不能使用char[],可以使用二维数组char[][],或者直接使用char； tip：这里直接用的四个输出语句，但是leetcode上要求用函数，所以要用return返回整个字符串，但是C语言有涉及到char*类型数组的拼接，暂时没搞出来，而java直接用的String类型的，所以直接用java代码提交的；补充：C语言leetcode版本123456789101112131415161718192021222324#include&lt;string.h&gt;char str1[30];char* intToRoman(int num) &#123; char *thousands[4]=&#123;"","M","MM","MMM"&#125;; char *hundreds[10]=&#123;"","C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; char *tens[10] = &#123;"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"&#125;; char *digits[10] = &#123;"","I","II","III","IV","V","VI","VII","VIII","IX"&#125;; strcpy(str1,thousands[num/1000]); char str2[4]; strcpy(str2,hundreds[num%1000/100]); char str3[4]; strcpy(str3,tens[num%100/10]); char str4[4]; strcpy(str4,digits[num%10]); strcat(str1,str2); strcat(str1,str3); strcat(str1,str4); return str1;&#125; 这里需要主义的是str1必须要设成全局变量，否则没有办法传出去，另外，strcat使用时前面那个一定要分配足够大的空间，否则就会runtime error！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>LeetCode日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome Number]]></title>
    <url>%2F2018%2F03%2F12%2FPalindrome-Number%2F</url>
    <content type="text"><![CDATA[这道题也是比较简单的，我是在上题“Reverse Integer”的基础上直接做的。这样一来就非常简单了。 代码如下：1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int a,b,c,i,d=0; scanf("%d",&amp;a); int flag=a&lt;0?-1:1; if(a&lt;0) a=abs(a); int tag1=a; while(a&gt;0) &#123; int temp=d; d=d*10; if(temp!=d/10) printf("不是回数")； d=d+a%10; a=a/10; &#125; if(d==tag1*flag) printf("是回数"); else printf("不是回数"); return 0;&#125; 这里要注意一下，负数都不是回数！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>LeetCode日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse Integer]]></title>
    <url>%2F2018%2F03%2F11%2FReverse-Integer%2F</url>
    <content type="text"><![CDATA[这道题也是比较简单的一道题，在leetcode上是easy，但是也是有些细节需要注意一下。代码如下 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; //int min_value =0x80000000,max_value=0x7fffffff; int a,b,c,d=0,f; printf("请输入："); scanf("%d",&amp;a); //if(a&lt;=min_value||a&gt;=max_value) //return -1; int flag=a&lt;0?-1:1; if(a&lt;0) a=abs(a); while(a&gt;0) &#123; int temp=d; d=d*10; if(temp!=d/10) return -1;//注意溢出的处理 d=d+a%10;//精髓所在 a=a/10; &#125; d=d*flag; printf("%d",d); return 0;&#125; 上面代码中的temp！=d/10,就是为了试探我们的数据会不会有溢出，如果有溢出则直接报错。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>LeetCode日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[two sum]]></title>
    <url>%2F2018%2F03%2F09%2Ftwo-sum%2F</url>
    <content type="text"><![CDATA[最近开始刷leetcode上的题，这个题还是比较简单的，意思就是说从一堆数选择第一个满足相加等于你输入数字的两个数。C语言代码如下：123456789101112131415int* twoSum(int* nums, int numsSize, int target) &#123; int *a = (int*)malloc(2*sizeof(int)); for(int i = 0;i&lt;numsSize;i++) &#123; for(int j = i+1;(j&lt;numsSize &amp;&amp; j != i);j++) &#123; if(nums[i] + nums[j] == target) &#123; a[0] = i; a[1] = j; &#125; &#125; &#125; return a;&#125; 总体来说这道题还是比较简单的]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>LeetCode日常</tag>
      </tags>
  </entry>
</search>
